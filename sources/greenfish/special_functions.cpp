//----------------------------------------------------------------------------//
/*
  File:         special_functions.cpp

  Description:  Evaluation of special algebraic functions
*/
//----------------------------------------------------------------------------//


//----------------------------------------------------------------------------//
// Exponential integral function
// This function is taken from: 
// W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery:
//'Numerical recipes in Fortran: The art of scientific computing' 2.ed, 1986
//----------------------------------------------------------------------------//
double exp_int( int n, double x )
{

//----------------------------------------------------------------------------//
// Parameters
//----------------------------------------------------------------------------//
	double eul = 0.5772156649015329;
	int maxit = 1000;
	double eps = 1.0e-10;
	double fpmin = 1.0e-30;

//----------------------------------------------------------------------------//
// Local variables
//----------------------------------------------------------------------------//
	int i, j, nm1;
	double ans = 0.0;
	double a,b,c,d,del,fact,h,psi;

	nm1  = n - 1;

	if(n < 0 || x < 0.0 || (x == 0.0 && (n == 0 || n == 1)))
	{
		std::cerr << " [expint]: Bad argument" << std::endl;
	}
	else if(n == 0)
	{
		ans = exp(-x)/x;
	}
	else if(x == 0.0)
	{
		ans = 1.0/double(nm1);
	}
	else if(x > 1.0)
	{
		b = x + double(n);
		c = 1.0/fpmin;
		d = 1.0/b;
		h = d;
		for(i = 1; i <= maxit; ++i)
		{
			a = double(-i*(nm1 + i));
			b = b + 2.0;
			d = 1.0/(a*d + b);
			c = b + a/c;
			del = c*d;
			h = h*del;
			if( std::abs(del - 1.0) < eps )
			{
				ans = h*exp(-x);
				return ans;
			}
		}
		std::cerr << " [expint]: Continued fractions did not converge." << std::endl;
	}
	else
	{
		if(nm1 != 0)
		{
			ans = 1.0/double(nm1);
		}
		else
		{
			ans = -log(x)-eul;
		}
		fact = 1.0;

		for(i = 1; i <= maxit; ++i)
		{
			fact = -fact*x/double(i);
			if(i != nm1)
			{
				del = -fact/double(i-nm1);
			}
			else
			{
				psi = -eul;
				for( j = 1; j <= nm1; ++j )
				{
					psi = psi + 1.0/double(j);
				}
				del = fact*(-log(x) + psi);
			}
			ans += del;
			if( std::abs(del) < std::abs(ans)*eps ){ return ans; }
		}
		std::cerr << " [expint]: Series did not converge" << std::endl;
	}

//----------------------------------------------------------------------------//
// Return
//----------------------------------------------------------------------------//
	return ans;
}

//----------------------------------------------------------------------------//
// Approximation by Chebyshev polynomials to the integral Bessel function 
// of first kind and order 0: Ji0 = int( q^(-1) (1 - J0) )
// Luke, Y. L: Mathematical functions and their approximations (1975) Table 9.3
//----------------------------------------------------------------------------//
double bessel_int_J0( double x )
{
	const double pi = acos(-1.0);
	const double gamma = 0.5772156649015329;

	double a[18] = {  1.35105091918187636388,
	                  0.83791030734868376979,
	                 -0.35047963978529462711,
	                  0.12777415867753198659,
	                 -0.02981035698255560990,
	                  0.00455219841169387328,
	                 -0.00048408621967185359,
	                  0.00003780202859916883,
	                 -0.00000225886908506771,
	                  0.00000010664609068423,
	                 -0.00000000408005443149,
	                  0.00000000012909996251,
	                 -0.00000000000343577839,
	                  0.00000000000007799552,
	                 -0.00000000000000152842,
	                  0.00000000000000002612,
	                 -0.00000000000000000039,
	                  0.00000000000000000001 };

	std::complex<double> c[39] = { { 0.95360150809738558095,-0.13917925930200001236},
	                               {-0.05860838853872331670,-0.12902065726135067062},
	                               {-0.01020283575659856676, 0.01103004348109535741},
	                               { 0.00196012704043622581, 0.00051817180856880364},
	                               {-0.00009574977697756219,-0.00030928210173975681},
	                               {-0.00003570479477043714, 0.00004647098443047525},
	                               { 0.00001169677960430223,-0.00000008198845340928},
	                               {-0.00000164386246452682,-0.00000191888381006925},
	                               {-0.00000007415845751760, 0.00000057813667761104},
	                               { 0.00000011434387527717,-0.00000008448997773317},
	                               {-0.00000003600903214141,-0.00000000525612161520},
	                               { 0.00000000601257386446, 0.00000000763257790924},
	                               { 0.00000000019124656215,-0.00000000268643963177},
	                               {-0.00000000054892028385, 0.00000000054279949860},
	                               { 0.00000000022740445656,-0.00000000001744365343},
	                               {-0.00000000005671490865,-0.00000000003975692920},
	                               { 0.00000000000607510983, 0.00000000002069683990},
	                               { 0.00000000000252060520,-0.00000000000639623674},
	                               {-0.00000000000191255246, 0.00000000000116359235},
	                               { 0.00000000000074056501, 0.00000000000006759603},
	                               {-0.00000000000018950214,-0.00000000000016557337},
	                               { 0.00000000000002021389, 0.00000000000008425597},
	                               { 0.00000000000001103617,-0.00000000000002824474},
	                               {-0.00000000000000889993, 0.00000000000000607698},
	                               { 0.00000000000000388558,-0.00000000000000003171},
	                               {-0.00000000000000119200,-0.00000000000000077237},
	                               { 0.00000000000000021456, 0.00000000000000048022},
	                               { 0.00000000000000002915,-0.00000000000000019502},
	                               {-0.00000000000000004877, 0.00000000000000005671},
	                               { 0.00000000000000002737,-0.00000000000000000862},
	                               {-0.00000000000000001080,-0.00000000000000000269},
	                               { 0.00000000000000000308, 0.00000000000000000309},
	                               {-0.00000000000000000042,-0.00000000000000000167},
	                               {-0.00000000000000000020, 0.00000000000000000066},
	                               { 0.00000000000000000020,-0.00000000000000000019},
	                               {-0.00000000000000000011, 0.00000000000000000003},
	                               { 0.00000000000000000004, 0.00000000000000000001},
	                               {-0.00000000000000000001,-0.00000000000000000001},
	                               { 0.00000000000000000000, 0.00000000000000000001} };


	int i;
	double ans;
	double T[3];
	double x8 = 0.125*x;
	double x5sh = 2.0*5.0/x - 1.0;
	double fac;
	std::complex<double> sum;

	if( x < 8.0 )
	{
		T[0] = 1.0;
		T[1] = x8;

		ans = T[0] * a[0];
		for( i = 2; i < 36; ++i )
		{
			T[2] = 2*x8*T[1] - T[0];

			if( i % 2 == 0 )
			{
				ans += a[i/2] * T[2];
			}
			T[0] = T[1];
			T[1] = T[2];
		}
	}
	else
	{
		T[0] = 1.0;
		T[1] = x5sh;

		sum  = c[0]*T[0];
		sum += c[1]*T[1];
		for( i = 2; i < 39; ++i )
		{
			T[2] = 2.0*x5sh*T[1] - T[0];
			T[0] = T[1];
			T[1] = T[2];

			sum += c[i] * T[2];
		}
		fac = cos(x + 0.25 * pi) * std::real( sum ) - sin(x + 0.25 * pi) * std::imag( sum );
		ans = sqrt( 2.0/(pi*x) )/x * fac + gamma + log(0.5*x);
	}

//----------------------------------------------------------------------------//
// Return
//----------------------------------------------------------------------------//
	return ans;
}


//----------------------------------------------------------------------------//
// Sine integral function
// This function is taken from: 
// W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery:
//'Numerical recipes in Fortran: The art of scientific computing' 2.ed, 1986
//----------------------------------------------------------------------------//
double sine_int( double x)
{
//----------------------------------------------------------------------------//
// Local variables
//----------------------------------------------------------------------------//
	const double pi = acos(-1.0);
	const double gamma = 0.5772156649015329;

	int maxit = 1000;
	double eps = 1.0e-10;
	double fpmin = 1.0e-30;
	double fpmax = 1.0e30;
	double tmin = 2.0;

	int i,k;

	double a,err,fact,sign,sum,sumc,sums,t,term;
	std::complex<double> h,g,b,c,d,del;
	bool odd;

	double ans = 0.0;

	t = std::abs(x);
	if(t == 0.0)
	{
		ans = 0.0;
		return ans;
	}

// Evaluate continued fraction by modified Lentz’s method (§5.2).
	if(t > tmin)
	{
		b = {1.0,t};
		c = fpmax;
		d = 1.0/b;
		h = d;

		i = 2;
		err = 1.0;
		while( i < maxit && err > eps )
		{
			a = -pow( i-1 ,2);
			b = b + 2.0;
			d = 1.0/(a*d+b); // Denominators cannot be zero.
			c = b + a/c;
			del = c*d;
			h = h*del;

			err = std::abs( std::real( del-1.0 ) ) + std::abs( std::imag( del-1.0 ) );
			++i;

		}

		if(i >= maxit){ std::cerr << "Continued fraction failed" << std::endl; }

		g = {cos(t),-sin(t)};
		h = g * h;

		ans = 0.5*pi + std::imag(h);
	}
// Evaluate both series simultaneously.
	else
	{

// Special case: avoid failure of convergence test because of underflow.
		if(t < sqrt(fpmin))
		{
			sumc = 0.0;
			sums = t;
		}
		else
		{
			sum  = 0.0;
			sums = 0.0;
			sumc = 0.0;
			sign = 1.0;
			fact = 1.0;
			odd  = true;

			k = 1;
			err = 1.0;
			while( k <= maxit && err > eps )
			{
				fact = fact*t/k;
				term = fact/k;
				sum = sum + sign*term;
				err = term/std::abs(sum);
				if(odd)
				{
					sign = -sign;
					sums = sum;
					sum  = sumc;
				}
				else
				{
					sumc = sum;
					sum  = sums;
				}

				odd = !odd;
				++k;
			}
			if(k >= maxit){ std::cerr << "MAXIT exceeded" << std::endl; }
		}

		ans = sums;
	}

	if(x < 0.0){ ans = -ans; }

//----------------------------------------------------------------------------//
// Return
//----------------------------------------------------------------------------//
	return ans;
}





